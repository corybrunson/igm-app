as.numeric(sleepstudy$Subject)
print(m1_g2s) # standard stan output
stanmer(m1_g2s) # cleaned up stan output
plot(m1_g2s) # *looks like shit
traceplot(m1_g2s)
traceplot(m1_g2s)
?lmer2stan
?lm2stan
install.packages("systemfit")
library(systemfit)
data(Kmenta)
attach(Kmenta)
eqDemand <- consump ~ price + income
eqSupply <- consump ~ price + farmPrice + trend
str(Kmenta)
eqSystem <- list(demand = eqDemand, supply = eqSupply)
fitols <- systemfit(eqSystem)
print(fitols)
fitsur <- systemfit(eqSystem, method = "SUR")
print(fitsur)
fit3sls <- systemfit(eqSystem, method = "3SLS",
inst = ~ income + farmPrice + trend)
fit3sls2 <- systemfit(eqSystem, method = "3SLS",
inst = list(~ farmPrice + trend,
~ income + farmPrice + trend))
restrict <- "demand_price + supply_farmPrice = 0"
fitsurRmat <- systemfit(eqSystem, method = "SUR",
restrict.matrix = restrict)
fitsurRmat
Rmat <- matrix(0, nrow = 1, ncol = 7)
Rmat[1, 2] <- 1
Rmat[1, 6] <- 1
qvec <- c(0)
fitsurRmatNum <- systemfit(eqSystem, method = "SUR",
restrict.matrix = Rmat, restrict.rhs = qvec)
fitsurRmatNum
library(SNPRelate)
install.packages(SNPRelate)
install.packages("SNPRelate")
source("http://bioconductor.org/biocLite.R")
biocLite("gdsfmt")
biocLite("SNPRelate")
library(gdsfmt)
library(devtools)
install_github("zhengxwen/gdsfmt")
library(gdsfmt)
library(SNPRelate)
install_github("zhengxwen/SNPRelate")
library(SNPRelate)
library(NMF)
nmf
seed
rpois(lambda = 1000)
rpois(lambda = 1000, n = 1)
install.packages("rgl")
library(rgl)
library(rgl)
library(hglm)
install_packages("hglm")
install.packages("hglm")
library(hglm)
data(sleepstudy)
library(lme)
library(lme4)
data(sleepstudy)
dat <- NULL
rbindlist(list(dat, data.table(a=1:5,b=6:10)))
library(data.table)
rbindlist(list(dat, data.table(a=1:5,b=6:10)))
rbindlist(list(dat, data.table(a=1:5,b=6:10), NULL))
?match.arg
Sys.sleep(10)
library(devtools)
devel = TRUE
if (devel) {
load_all("~/Documents/edu/R/cloud")
} else {
install_github("corybrunson/cloud")
library(cloud)
}
library(knitr)
opts_chunk$set(echo=FALSE, results=FALSE, message=FALSE, warning=FALSE)
data(Target)
print(Target)
print(class(Target))
T_freq <- rep(1 / nrow(Target), nrow(Target))
plot(xlim = c(-19, 19), ylim = c(-19, 19), axes = FALSE, asp = 1,
Target, pch = 16,
xlab = "", ylab = "")
text(Target, labels = rownames(Target), pos = 1)
rect(xleft = -19, xright = 19, ybottom = -19, ytop = 19, lty = 3)
legend(x = -19, y = 19, box.lty = 0, legend = "Target example")
G <- barycenter(Target)
print(G)
# Vectors from barycenter to each point
T_vectors <- Target - do.call(rbind,
replicate(nrow(Target),
G,
simplify = FALSE))
# Plot barycenter and vectors therefrom to points in cloud
plot(xlim = c(-19, 19), ylim = c(-19, 19), axes = FALSE, asp = 1,
x = c(), y = c(),
xlab = "", ylab = "")
text(G, labels = "G", adj = c(1.5, 1.25))
for (i in 1:nrow(Target)) {
text(Target[i, , drop = FALSE], labels = rownames(Target)[i],
adj = .5 - (T_vectors[i, ] / sqrt(sum(T_vectors[i, ] ^ 2))))
}
arrows(x0 = G[, 1], y0 = G[, 2],
x1 = Target[, 1], y1 = Target[, 2],
length = .15, angle = 15)
rect(xleft = -19, xright = 19, ybottom = -19, ytop = 19, lty = 3)
legend(x = -19, y = 19, box.lty = 0,
legend = "Target: barycentric characterization")
P <- c(0, 0)
P_in <- inertia(point = P, cloud = Target)
G_in <- inertia(point = G, cloud = Target)
T_var <- inertia(G, cloud = Target,
weights = T_freq)
print(c(center_inertia = P_in,
barycenter_inertia = G_in,
variance = T_var))
Ctas <- T_freq * apply(Target, 1, function(m) {
sum((m - G) ^ 2)
})
Ctrs <- Ctas / T_var
print(cbind(Ctas, Ctrs))
huyghen_test(point = P, cloud = Target, weights = T_freq)
huyghen_test(point = G, cloud = Target, weights = T_freq)
# Three plots!
par(mfrow = c(1, 3))
# Plot points relative to center
plot(xlim = c(-19, 19), ylim = c(-19, 19), axes = FALSE, asp = 1,
Target, pch = 16,
xlab = "", ylab = "")
segments(x0 = 0, y0 = 0, x1 = Target[, 1], y1 = Target[, 2])
text(x = P[1], y = P[2], labels = "P",
adj = c(sqrt(2), sqrt(2)))
rect(xleft = -19, xright = 19, ybottom = -19, ytop = 19, lty = 3)
# Plot center relative to barycenter
plot(xlim = c(-19, 19), ylim = c(-19, 19), axes = FALSE, asp = 1,
x = c(), y = c(),
xlab = "", ylab = "")
points(rbind(P, G),
pch = c(13, 21), bg = c("white", "grey"), cex = 2)
segments(x0 = P[1], y0 = P[2],
x1 = G[1], y1 = G[2])
text(x = rbind(P, G),
labels = c("P", "G"), adj = c(1, -1))
rect(xleft = -19, xright = 19, ybottom = -19, ytop = 19, lty = 3)
# Plot points relative to barycenter
plot(xlim = c(-19, 19), ylim = c(-19, 19), axes = FALSE, asp = 1,
Target, pch = 16,
xlab = "", ylab = "")
segments(x0 = G[1], y0 = G[2],
x1 = Target[, 1], y1 = Target[, 2])
text(x = G[1], y = G[2], labels = "G",
adj = c(sqrt(3), 1))
rect(xleft = -19, xright = 19, ybottom = -19, ytop = 19, lty = 3)
# Reset
par(mfrow = c(1, 1))
axis <- rbind(c(0, 0), c(2, 1))
axis_var <- direction_variance(cloud = Target, weights = T_freq,
subspace = axis)
print(axis_var)
print(direction_variance(cloud = Target, weights = T_freq,
subspace = affine_decomposition(axis)$linear_subspace,
type = "linear"))
# Three plots!
par(mfrow = c(1, 2))
# Plot cloud, axis, and residual segments
plot(xlim = c(-19, 19), ylim = c(-19, 19), axes = FALSE, asp = 1,
Target, pch = 16,
xlab = "", ylab = "")
points(x = P[1], y = P[2], pch = 13, cex = 2)
m <- diff(axis[, 2]) / diff(axis[, 1])
abline(a = axis[1, 2] - m * axis[1, 1], b = m, lty = 2)
rect(xleft = -19, xright = 19, ybottom = -19, ytop = 19, lty = 3)
# Plot center relative to barycenter
plot(xlim = c(-19, 19), ylim = c(-19, 19), axes = FALSE, asp = 1,
x = c(), y = c(),
xlab = "", ylab = "")
points(rbind(P, G),
pch = c(13, 21), bg = c("white", "grey"), cex = 2)
segments(x0 = P[1], y0 = P[2],
x1 = G[1], y1 = G[2])
text(x = rbind(P, G),
labels = c("P", "G"), adj = c(1, -1))
rect(xleft = -19, xright = 19, ybottom = -19, ytop = 19, lty = 3)
# Plot cloud, new axis, and new residual segments
# Reset
par(mfrow = c(1, 1))
huyghen_general_test(cloud = Target, weights = T_freq, subspace = axis)
cloud_decomposition(cloud = Target, subspace = axis)
cloud_variance_test(cloud = Target, weights = T_freq, subspace = axis)
axis
direction_vector <- axis[2, ] - axis[1, ]
direction_vector
alpha <- axis[2, ] - axis[1, ]
covariant_var <- axis_coordinates(cloud = Target,
dir_vec = alpha,
variable = "covariant")
covariant_var
vars <- sapply(c("covariant", "calibrated", "standard", "axial"),
axis_coordinates, cloud = Target, dir_vec = alpha)
vars
affine_decomposition(axis)
alpha <- affine_decomposition(axis)$linear_subspace
alpha
vars <- sapply(c("covariant", "calibrated", "standard", "axial"),
axis_coordinates, cloud = Target, dir_vec = alpha)
#' Variables attached to an axis
#'
#' The following functions inpute a point cloud (as a matrix of coordinates) and
#' an axis (as a direction vector), and return the coordinates of a desired
#' variable with respect to the cloud attached to the axis.
#' @param cloud An m-by-n matrix of coordinates for m points in n-dimensional
#'   space.
#' @param dir_vec An n-dimensional vector giving the direction of the axis
#'   through the cloud.
#' @param variable Character; which variable to calculate, from among
#'   \code{covariant}, \code{calibrated}, \code{standard}, and \code{axial}.
#'   Does not default.
#' @export
axis_coordinates <-
function(cloud, dir_vec, variable) {
# Match variable
variable <- match.arg(variable, c("covariant", "calibrated",
"standard", "axial"))
# Barycenter
bc <- barycenter(cloud)
# Barycentered cloud
centered_cloud <- cloud - rep(bc, each = nrow(cloud))
# Inner product with direction vector
covariant_var <- centered_cloud %*% as.vector(dir_vec)
if (variable == "covariant") return(covariant_var)
# Magnitude of dir_vec
mag <- sqrt(sum(dir_vec * dir_vec))
if (variable == "axial") {
covariant_var / (mag ^ 2)
} else {
calibrated_var <- covariant_var / mag
if (variable == "calibrated") {
calibrated_var
} else {
calibrated_var / sd(calibrated_var)
}
}
}
vars <- sapply(c("covariant", "calibrated", "standard", "axial"),
axis_coordinates, cloud = Target, dir_vec = alpha)
vars
print(vars)
alpha <- affine_decomposition(axis)$linear_subspace
coords <- sapply(c("covariant", "calibrated", "standard", "axial"),
axis_coordinates, cloud = Target, dir_vec = alpha)
print(vars)
alpha <- affine_decomposition(axis)$linear_subspace
coords <- sapply(c("covariant", "calibrated", "standard", "axial"),
axis_coordinates, cloud = Target, dir_vec = alpha)
print(coords)
i=1
while(NA) {i <- i+1}
i
while(TRUE | NA) {i <- i+1}
i
i=1
while(FALSE & NA) {i <- i+1}
i
while(NA & FALSE) {i <- i+1}
i
grepl("test", c())
while(grepl("test", c()) & FALSE) {i <- i+1}
while(FALSE & grepl("test", c())) {i <- i+1}
library(systemfit)
data(Kmenta)
attach(Kmenta)
library(systemfit)
data(Kmenta)
attach(Kmenta)
# Set working directory
setwd("~/Documents/edu/R/igm.chicago/shiny/consensusTriangle")
# Install and load packages
for (pkg in c("data.table", "shiny", "shinythemes")) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
stopifnot(require(pkg, character.only = TRUE))
}
}
# Load stored survey data
allDat <- readRDS("igm.rds")
# Assign values -1, 0, 1 to Disagree, Uncertain, Agree
vote.agree <- c(
"Strongly Disagree" = -1, "Disagree" = -1,
"Uncertain" = 0,
"Agree" = 1, "Strongly Agree" = 1
)
allDat[, agree := vote.agree[vote]]
# Assign values 0, 1 to Strongly, ~Strongly (caution: 0 for NA)
allDat[, strong := as.numeric(grepl("Strongly", vote))]
# Standardize confidence
allDat[, stdconf := confidence / mean(confidence, na.rm = TRUE)]
# Number of economists polled
allDat[, count := length(vote), by = list(id, question)]
# Source triangle coordinate functions (used in server script)
source("fun_coord.R")
# Source user interface
source("ui_tabs.R")
# Source server
source("server_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
# Source server
source("server_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
# Source server
source("server_tabs.R")
shinyApp(ui = ui, server = server)
is.null(NULL)
is.null(list(NULL, NULL))
source("ui_tabs.R")
# Source server
source("server_tabs.R")
shinyApp(ui = ui, server = server)
# Source user interface
source("ui_tabs.R")
# Source server
source("server_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
source("ui_tabs.R")
source("server_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
descr <- readChar("description.txt")
descr <- paste(lines("description.txt"), collapse = "")
descr <- paste(readLines("description.txt"), collapse = "")
descr
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
# Install and load packages
for (pkg in c("data.table", "shiny", "shinythemes")) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
stopifnot(require(pkg, character.only = TRUE))
}
}
# Load stored survey data
allDat <- readRDS("igm.rds")
# Assign values -1, 0, 1 to Disagree, Uncertain, Agree
vote.agree <- c(
"Strongly Disagree" = -1, "Disagree" = -1,
"Uncertain" = 0,
"Agree" = 1, "Strongly Agree" = 1
)
allDat[, agree := vote.agree[vote]]
# Assign values 0, 1 to Strongly, ~Strongly (caution: 0 for NA)
allDat[, strong := as.numeric(grepl("Strongly", vote))]
# Standardize confidence
allDat[, stdconf := confidence / mean(confidence, na.rm = TRUE)]
# Number of economists polled
allDat[, count := length(vote), by = list(id, question)]
# Source triangle coordinate functions (used in server script)
source("fun_coord.R")
source("ui_tabs.R")
source("server_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
file.exists("igm.rds")
getwd()
# Install and load packages
for (pkg in c("data.table", "shiny", "shinythemes")) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
stopifnot(require(pkg, character.only = TRUE))
}
}
# Scrape data if necessary
if (!file.exists("igm.rds")) source("scrape.R")
# Load stored survey data
allDat <- readRDS("igm.rds")
# Assign values -1, 0, 1 to Disagree, Uncertain, Agree
vote.agree <- c(
"Strongly Disagree" = -1, "Disagree" = -1,
"Uncertain" = 0,
"Agree" = 1, "Strongly Agree" = 1
)
allDat[, agree := vote.agree[vote]]
# Assign values 0, 1 to Strongly, ~Strongly (caution: 0 for NA)
allDat[, strong := as.numeric(grepl("Strongly", vote))]
# Standardize confidence
allDat[, stdconf := confidence / mean(confidence, na.rm = TRUE)]
# Number of economists polled
allDat[, count := length(vote), by = list(id, question)]
# Source triangle coordinate functions (used in server script)
source("fun_coord.R")
# Source user interface
source("ui_tabs.R")
# Source server
source("server_tabs.R")
# Run app!
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
?checkboxInput
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
source("server_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
# Source server
source("server_tabs.R")
# Run app!
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
# Source server
source("server_tabs.R")
# Run app!
shinyApp(ui = ui, server = server)
# Install and load packages
for (pkg in c("data.table", "shiny", "shinythemes")) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
stopifnot(require(pkg, character.only = TRUE))
}
}
file.exists("igm.rds")
if (!file.exists("igm.rds")) source("scrape.R")
# Load stored survey data
allDat <- readRDS("igm.rds")
# Assign values -1, 0, 1 to Disagree, Uncertain, Agree
vote.agree <- c(
"Strongly Disagree" = -1, "Disagree" = -1,
"Uncertain" = 0,
"Agree" = 1, "Strongly Agree" = 1
)
allDat[, agree := vote.agree[vote]]
# Assign values 0, 1 to Strongly, ~Strongly (caution: 0 for NA)
allDat[, strong := as.numeric(grepl("Strongly", vote))]
# Standardize confidence
allDat[, stdconf := confidence / mean(confidence, na.rm = TRUE)]
# Number of economists polled
allDat[, count := length(vote), by = list(id, question)]
# Source triangle coordinate functions (used in server script)
source("fun_coord.R")
# Source user interface
# http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("ui_tabs.R")
# Source server
source("server_tabs.R")
# Run app!
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
?controlPanel
?conditionalPanel
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
source("ui_tabs.R")
shinyApp(ui = ui, server = server)
# Install and load packages
for (pkg in c("data.table", "shiny", "shinythemes")) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
stopifnot(require(pkg, character.only = TRUE))
}
}
allDat <- readRDS("igm.rds")
source("ui.R")
library(shiny)
source("ui.R")
source("server.R")
source("ui.R")
shinyApp(ui = ui, server = server)

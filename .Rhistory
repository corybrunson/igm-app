source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
hist(allDat$stdlogitconf)
hist((allDat$stdlogitconf))
?qlogis
qlogis(.75)
1 / (1 + exp(.75))
1 / (1 + exp((.75 - 0) / 1))
1 / (1 + exp(-.75))
exp(.75) / (1 + exp(.75))
exp(.75) / ((1 + exp(.75))^2)
log(.75 / (1 - .75))
plogis(1.098612)
hist(plogis(allDat$stdlogitconf) * 11)
range(plogis(allDat$stdlogitconf) * 11)
range(plogis(allDat$stdlogitconf) * 11, na.rm = TRUE)
range(hist(allDat$stdlogitconf))
range(allDat$stdlogitconf)
range(allDat$stdlogitconf, na.rm = TRUE)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
source("app/server.R")
?plogit
source("app/server.R")
source("app/ui.R")
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
qlogis(.75)
plogis(1.098612)
log(.75/(1-.75))
exp(1.098612)/(1+exp(1.098612))
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
a# Source server
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
# Source server
source("app/server.R")
# Source user interface
# TeX to html: http://hutchinson.belmont.ma.us/tth/manual/sec3.html
source("app/ui.R")
# Run app!
shinyApp(ui = ui, server = server)
source("app/server.R")
source("app/ui.R")
shinyApp(ui = ui, server = server)
source("app/server.R")
source("app/ui.R")
shinyApp(ui = ui, server = server)
shinyApp(ui = ui, server = server)
source("scripts/polish.R")
source("scripts/fun_coord.R")
library(dplyr)
output$strconf <- renderPlot({
# Retrieve highlighted data
dat <- allDat
# Confidence variable
dat$conf_var <- if (input$conf.var == "Raw") {
dat$confidence
} else {
dat$logit.conf
}
# Confidence distribution across vote options
boxplot(conf_var ~ factor(vote), data = dat, outline = FALSE,
xlab = "Vote",
ylab = if (input$conf.var == "Raw") "Confidence" else
"Logit-Confidence")
points(x = jitter(as.numeric(factor(dat$vote))),
y = jitter(dat$conf_var),
pch = 16, cex = .33, col = rgb(0, 0, 0, .33))
# Standard deviations
mean_sd <- summarise(
group_by(dat, vote),
mean = mean(conf_var, na.rm = TRUE),
sd = sd(conf_var, na.rm = TRUE)
)
mean_sd <- mean_sd[order(mean_sd$vote, na.last = NA), ]
means_sds <- paste0(sprintf("%.1f", round(mean_sd$mean, 1)), " (",
sprintf("%.1f", round(mean_sd$sd, 1)), ")")
# Axis
axis(side = 3, at = 1:5, tck = 0, labels = means_sds)
mtext(side = 3, line = 3, text = "Mean (std dev)")
})
output <- list()
output$strconf <- renderPlot({
# Retrieve highlighted data
dat <- allDat
# Confidence variable
dat$conf_var <- if (input$conf.var == "Raw") {
dat$confidence
} else {
dat$logit.conf
}
# Confidence distribution across vote options
boxplot(conf_var ~ factor(vote), data = dat, outline = FALSE,
xlab = "Vote",
ylab = if (input$conf.var == "Raw") "Confidence" else
"Logit-Confidence")
points(x = jitter(as.numeric(factor(dat$vote))),
y = jitter(dat$conf_var),
pch = 16, cex = .33, col = rgb(0, 0, 0, .33))
# Standard deviations
mean_sd <- summarise(
group_by(dat, vote),
mean = mean(conf_var, na.rm = TRUE),
sd = sd(conf_var, na.rm = TRUE)
)
mean_sd <- mean_sd[order(mean_sd$vote, na.last = NA), ]
means_sds <- paste0(sprintf("%.1f", round(mean_sd$mean, 1)), " (",
sprintf("%.1f", round(mean_sd$sd, 1)), ")")
# Axis
axis(side = 3, at = 1:5, tck = 0, labels = means_sds)
mtext(side = 3, line = 3, text = "Mean (std dev)")
})
rm(output)
allDat
dat <- allDat
# Confidence variable
dat$conf_var <- if (input$conf.var == "Raw") {
dat$confidence
} else {
dat$logit.conf
}
input <- list()
input$conf.var <- "Raw"
# Confidence variable
dat$conf_var <- if (input$conf.var == "Raw") {
dat$confidence
} else {
dat$logit.conf
}
# Confidence distribution across vote options
boxplot(conf_var ~ factor(vote), data = dat, outline = FALSE,
xlab = "Vote",
ylab = if (input$conf.var == "Raw") "Confidence" else
"Logit-Confidence")
points(x = jitter(as.numeric(factor(dat$vote))),
y = jitter(dat$conf_var),
pch = 16, cex = .33, col = rgb(0, 0, 0, .33))
# Standard deviations
mean_sd <- summarise(
group_by(dat, vote),
mean = mean(conf_var, na.rm = TRUE),
sd = sd(conf_var, na.rm = TRUE)
)
mean_sd <- mean_sd[order(mean_sd$vote, na.last = NA), ]
means_sds <- paste0(sprintf("%.1f", round(mean_sd$mean, 1)), " (",
sprintf("%.1f", round(mean_sd$sd, 1)), ")")
# Axis
axis(side = 3, at = 1:5, tck = 0, labels = means_sds)
mtext(side = 3, line = 3, text = "Mean (std dev)")
dat <- allDat
input$panelist <- "-"
# Spotlight panelists
if (input$panelist == "-") {
dat$hl.panelist <- FALSE
} else {
dat$hl.panelist <- (dat$panelist == input$panelist)
}
dat$hl.topic <- if (input$topic == "") {
TRUE
} else {
grepl(input$topic, paste(dat$topic, dat$statement))
}
input$topic <- ""
dat$hl.topic <- if (input$topic == "") {
TRUE
} else {
grepl(input$topic, paste(dat$topic, dat$statement))
}
by_id_question <- group_by(dat, id, question)
dat <- mutate(by_id_question,
hl.panelist = any(hl.panelist),
hl.topic = any(hl.topic))
dat
by_id_question <- group_by(dat, id, question)
dat <- mutate(
by_id_question,
X = sum((1 - input$conf.wt + input$conf.wt * stdconf) *
as.numeric(agree == 0), na.rm = TRUE) /
sum(1 - input$conf.wt + input$conf.wt * stdconf, na.rm = TRUE),
Y = consensus(agree * (1 + input$str.wt * strong)),
#Y = sum(apply(combn(sign(agree), 2), 2, prod), na.rm = TRUE) /
#    choose(length(which(agree != 0 & !is.na(agree))), 2),
x = x(c(sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == -1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == 1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
as.numeric(agree == 0), na.rm = TRUE))),
y = y(c(sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == -1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == 1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
as.numeric(agree == 0), na.rm = TRUE)))
)
n
m
input$str.wt <- 0
input$conf.wt
input$conf.wt <- 0
# Add vs and triangle coordinates to data table
dat <- mutate(
by_id_question,
X = sum((1 - input$conf.wt + input$conf.wt * stdconf) *
as.numeric(agree == 0), na.rm = TRUE) /
sum(1 - input$conf.wt + input$conf.wt * stdconf, na.rm = TRUE),
Y = consensus(agree * (1 + input$str.wt * strong)),
#Y = sum(apply(combn(sign(agree), 2), 2, prod), na.rm = TRUE) /
#    choose(length(which(agree != 0 & !is.na(agree))), 2),
x = x(c(sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == -1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == 1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
as.numeric(agree == 0), na.rm = TRUE))),
y = y(c(sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == -1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
(1 + input$str.wt * strong) *
as.numeric(agree == 1),
na.rm = TRUE),
sum((1 - input$conf.wt + input$conf.wt * stdconf) *
as.numeric(agree == 0), na.rm = TRUE)))
)
dat <- xyDat()
num <- summarise(
group_by(dat, id, question),
count = n()
)
dat
dat <- unique(subset(dat,
select = c(id, date, question, topic, statement,
hl.panelist, hl.topic,
X, Y, x, y)))
stopifnot(nrow(dat) == nrow(num))
output$q <- renderText(nrow(dat))
dat <- merge(dat, num, by = c("id", "question"))
dat
head(dat)
dat$hl.panelist
input$p_subset
input$p_subset <- F
input$t_subset <- F
if (any(dat$hl.panelist) & !input$p_subset)
dat <- dat[hl.panelist == TRUE, ]
if (!input$t_subset) # & any(dat$hl.topic)
dat <- dat[hl.topic == TRUE, ]
names(dat)
is.data.table(dat)
data.table::is.data.table(dat)
if (any(dat$hl.panelist) & !input$p_subset)
dat <- filter(dat, hl.panelist == TRUE)
if (!input$t_subset) # & any(dat$hl.topic)
dat <- filter(dat, hl.topic == TRUE)
dat
range_vs <- reactiveValues(x = c(0, 1), y = c(0, 1))
source("app/server.R")
source("app/ui.R")
shinyApp(ui = ui, server = server)
?rename
test
test <- data.frame(x=1:3,y=letters[1:3])
test
rename(test, a = x, b = y)
rename(test, a = x + 1, b = y)
?mutate
source("app/server.R")
shinyApp(ui = ui, server = server)
?transmutate
?transmute
test
transmute(test, a = x, b = x + 1, c = y)
source("app/server.R")
shinyApp(ui = ui, server = server)
getwd()
library(shiny)
library(shinythemes)
load("data/igmpanel.rda")
allDat <- igmpanel
rm(igmpanel)
allDat
vote.agree <- c(
"Strongly Disagree" = -1, "Disagree" = -1,
"Uncertain" = 0,
"Agree" = 1, "Strongly Agree" = 1
)
allDat$agree <- vote.agree[allDat$vote]
allDat$vote <- factor(allDat$vote, levels = names(vote.agree))
allDat$strong <- as.numeric(grepl("Strongly", allDat$vote))
allDat$stdconf <- allDat$confidence / mean(allDat$confidence, na.rm = TRUE)
allDat$logit.conf <- qlogis(allDat$confidence / 11)
# Strength-specific distributions
allDat$strength <- factor(
ifelse(is.na(allDat$vote), NA,
ifelse(grepl("[Aa]gree", allDat$vote),
ifelse(grepl("^Strongly", allDat$vote), "2", "1"),
"0")),
levels = as.character(0:2)
)
mean.conf <- sapply(levels(allDat$strength), function(lev) {
mean(allDat[allDat$strength == lev, ]$logit.conf, na.rm = TRUE)
})
sd.conf <- sd(allDat$logit.conf, na.rm = TRUE)
allDat$stdlogitconf <- plogis(
(allDat$logit.conf - mean.conf[allDat$strength]) / sd.conf
) * 11
allDat$strength <- NULL
head(allDat)
rm(list=ls())
source("app/server.R")
source("app/ui.R")
shinyApp(ui = ui, server = server)
source("app/server.R")
shinyApp(ui = ui, server = server)
load("data/igmpanel.rda")
allDat <- readRDS("data/igm.rds")
head(igmpanel)
names(igmpanel)
names(allDat)
igmpanel[, c("topic", "question", "panelist", "vote")]
igmpanel[1:8, c("topic", "question", "panelist", "vote")]
allDat[1:8, c("topic", "question", "panelist", "vote")]
is.data.table(allDat)
head(allDat)
igmpanel[1:8, c("topic", "question", "panelist", "vote")]
as.data.frame(allDat)[1:8, c("topic", "question", "panelist", "vote")]
igmpanel[1:20, c("topic", "question", "panelist", "vote")]
as.data.frame(allDat)[1:20, c("topic", "question", "panelist", "vote")]
filter(igmpanel, topic == "Monetary Policy" & vote == "Strongly Disagree")
filter(igmpanel, topic == "Monetary Policy" & vote == "Strongly Disagree")[, c("topic", "question", "panelist", "vote")]
filter(allDat, topic == "Monetary Policy" & vote == "Strongly Disagree")[, c("topic", "question", "panelist", "vote")]
tail(igmpanel)
filter(igmpanel, topic == "Brexit II" & vote == "Disagree")[, c("topic", "question", "panelist", "vote")]
filter(allDat, topic == "Brexit II" & vote == "Disagree")[, c("topic", "question", "panelist", "vote")]
sample(igmpanel, size = 5)
sample(igmpanel$topic, size = 5)
filter(allDat, topic == "China-US Trade" & vote == "Disagree")[, c("topic", "question", "panelist", "vote")]
filter(allDat, topic == "Drug Use Policies" & vote == "Disagree")[, c("topic", "question", "panelist", "vote")]
filter(igmpanel, topic == "Drug Use Policies" & vote == "Disagree")[, c("topic", "question", "panelist", "vote")]
load("data/igmpanel.rda")
allDat <- igmpanel
rm(igmpanel)
head(allDat)
vote.agree <- c(
"Strongly Disagree" = -1, "Disagree" = -1,
"Uncertain" = 0,
"Agree" = 1, "Strongly Agree" = 1
)
allDat$agree <- vote.agree[allDat$vote]
# Factorize vote field
allDat$vote <- factor(allDat$vote, levels = names(vote.agree))
# Assign values 0, 1 to Strongly, ~Strongly (caution: 0 for NA)
allDat$strong <- as.numeric(grepl("Strongly", allDat$vote))
# Standardize confidence
allDat$stdconf <- allDat$confidence / mean(allDat$confidence, na.rm = TRUE)
# Logit-transform confidence values
allDat$logit.conf <- qlogis(allDat$confidence / 11)
# Strength-specific distributions
allDat$strength <- factor(
ifelse(is.na(allDat$vote), NA,
ifelse(grepl("[Aa]gree", allDat$vote),
ifelse(grepl("^Strongly", allDat$vote), "2", "1"),
"0")),
levels = as.character(0:2)
)
mean.conf <- sapply(levels(allDat$strength), function(lev) {
mean(allDat[allDat$strength == lev, ]$logit.conf, na.rm = TRUE)
})
sd.conf <- sd(allDat$logit.conf, na.rm = TRUE)
# Standardized confidence (logit-center-inverse logit)
allDat$stdlogitconf <- plogis(
(allDat$logit.conf - mean.conf[allDat$strength]) / sd.conf
) * 11
# Remove unnecessary values
allDat$strength <- NULL
igmpanel <- allDat
allDat <- readRDS("data/igm.rds")
# Assign values -1, 0, 1 to Disagree, Uncertain, Agree
vote.agree <- c(
"Strongly Disagree" = -1, "Disagree" = -1,
"Uncertain" = 0,
"Agree" = 1, "Strongly Agree" = 1
)
allDat$agree <- vote.agree[allDat$vote]
# Factorize vote field
allDat$vote <- factor(allDat$vote, levels = names(vote.agree))
# Assign values 0, 1 to Strongly, ~Strongly (caution: 0 for NA)
allDat$strong <- as.numeric(grepl("Strongly", allDat$vote))
# Standardize confidence
allDat$stdconf <- allDat$confidence / mean(allDat$confidence, na.rm = TRUE)
# Logit-transform confidence values
allDat$logit.conf <- qlogis(allDat$confidence / 11)
# Strength-specific distributions
allDat$strength <- factor(
ifelse(is.na(allDat$vote), NA,
ifelse(grepl("[Aa]gree", allDat$vote),
ifelse(grepl("^Strongly", allDat$vote), "2", "1"),
"0")),
levels = as.character(0:2)
)
mean.conf <- sapply(levels(allDat$strength), function(lev) {
mean(allDat[allDat$strength == lev, ]$logit.conf, na.rm = TRUE)
})
sd.conf <- sd(allDat$logit.conf, na.rm = TRUE)
# Standardized confidence (logit-center-inverse logit)
allDat$stdlogitconf <- plogis(
(allDat$logit.conf - mean.conf[allDat$strength]) / sd.conf
) * 11
# Remove unnecessary values
allDat$strength <- NULL
igmpanel
head(igmpanel)
?subset
head(igmpanel[, c("topic", "question", "panelist", "agree", "strong")])
filter(igmpanel, topic == "Monetary Policy" & vote == "Strongly Disagree")[, c("panelist", "agree", "strong")]
filter(allDat, topic == "Monetary Policy" & vote == "Strongly Disagree")[, c("panelist", "agree", "strong")]
filter(allDat, topic == "Monetary Policy" & vote == "Disagree")[, c("panelist", "agree", "strong")]
filter(igmpanel, topic == "Monetary Policy" & vote == "Disagree")[, c("panelist", "agree", "strong")]
mode(igmpanel$vote)
mode(allDat$vote)
rm(list=ls())
source("app/server.R")
source("app/ui.R")
shinyApp(ui = ui, server = server)
